#!/usr/bin/env python3
import argparse
import glob
import json
import os
import subprocess
from typing import Any, Dict, List, Tuple


def execute_message(s: str):
    """
    Decorator for long running function
    """

    def _wrap(f, *args, **kwargs):
        print(s, end="...", flush=True)
        r = f(*args, **kwargs)
        print("Done!", flush=True)
        return r

    return _wrap


def get_upstream_full(upstream_url) -> Dict[str, str]:
    nix_query = subprocess.Popen(
        ["nix", "search", "nixpkgs", "-I", upstream_url, "--json"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout, stderr = nix_query.communicate()
    return json.loads(stdout)


def drv_to_dict(drv_path: str) -> Dict[str, Any]:
    """
    Getting the DRV path using `nix derivative show`
    """
    _nix_deriv = subprocess.Popen(
        ["nix", "derivation", "show", drv_path],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout, stderr = _nix_deriv.communicate()
    return json.loads(stdout)[drv_path]


def get_nix_store(list_file: str) -> Dict[str, Any]:
    """
    Extracting the derivation information of packages listed in a plain text
    file. The plain should be a <package>-<version> line separted list,
    generated by dumping the contents of config.environment.systemPackages or
    similar.
    """
    try:
        package_list = open(list_file, "r").read().split("\n")
        drv_list = [
            path
            for pkg in package_list
            for path in glob.glob(f"/nix/store/*-{pkg}.drv")
        ]
        _nix_deriv = subprocess.Popen(
            ["nix", "derivation", "show", *drv_list],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        stdout, stderr = _nix_deriv.communicate()
        package_drv = {}
        # Additional parsing to be done
        for key, drv in json.loads(stdout).items():
            if "env" not in drv.keys():
                print(
                    f"Warning! Skipping over package [{key}] without 'env' settings",
                )
            if drv["system"] != "x86_64-linux":
                continue

            pname = drv["name"] if "pname" not in drv["env"] else drv["env"]["pname"]
            package_drv[pname] = drv
            package_drv[pname]["drv_path"] = key
        return package_drv
    except Exception as err:
        print(f"Warning! Ran into issue processing file [f{list_file}]. Skipping...")
        print(type(err), err)
        return {}


"""
Kernel and drivers will not be listed in the system environment packages, here
we handle them manually.
"""


def get_linux_drv():
    _uname = subprocess.Popen(
        ["uname", "-r"], stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    stdout, stderr = _uname.communicate()
    drv_glob = f"/nix/store/*-linux-{stdout.decode().strip()}.drv"
    drv_path = glob.glob(drv_glob)[-1]
    return drv_to_dict(drv_path)


def get_nvidia_drv():
    return {"env": {"version": "2.2.2"}, "system": "x86_64-linux"}


def get_discrepancies(upstream, local) -> List[Tuple[str, str, str, str]]:
    updates = []
    for pname, pconfig in local.items():
        # Skipping if no-local version can be determined
        if "version" not in pconfig["env"]:
            continue

        upsteam_compare = {
            uname: uconfig
            for uname, uconfig in upstream.items()
            if uconfig["pname"] == pname
        }
        if len(upsteam_compare) == 0:
            continue

        uversions = []
        for uname, uconfig in upsteam_compare.items():
            # Remove leading "legacyPackages." and post ".package"
            system = ".".join(uname.split(".")[1:-1])
            if system not in [  # Allowed package version extensions
                pconfig["system"],
                pconfig["system"] + ".kdePackages",
            ]:
                continue
            uv = uconfig["version"].replace("p", ".").replace("-", ".")
            if any(not x.isdigit() for x in uv.split(".")):
                continue
            uversions.append((uname, uconfig["version"]))

        # Listing just the latest version for comparison
        if len(uversions) == 0:
            continue  # If there are no valid version to compare
        uversions = sorted(
            uversions,
            key=lambda x: tuple(
                int(i)
                for i in ("0" + x[1]).replace("p", ".").replace("-", ".").split(".")
                if i.isdigit()
            ),
        )
        # Adding the upstream results to the compairson table
        updates.append(
            (pname, pconfig["env"]["version"], uversions[-1][0], uversions[-1][1])
        )
    return updates


def display_updates(updates: List[Tuple[str, str, str, str]]):
    for entry in updates:
        package_name = entry[0]
        local_version = entry[1]
        up_name = entry[2]
        up_version = entry[3]
        if local_version == up_version:
            continue
        if ".".join(up_name.split(".")[2:]) != package_name:
            print(f"{package_name}: {local_version} -> ({up_name}) {up_version}")
        else:
            print(f"{package_name}: {local_version} -> {up_version}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        "nix-check-update.py", "Helper script for checking for upstream updates"
    )
    parser.add_argument(
        "--nixpkgs",
        "-n",
        type=str,
        help="Argument passed to nix search to define the upstream source",
        default="nixpkgs=channel:nixos-unstable",
    )
    parser.add_argument(
        "--env",
        "-e",
        type=str,
        help="Path to file listing system environment packages",
        default=os.environ["NIXCUSTOM_ENV_PACKAGES"],
    )
    parser.add_argument(
        "--user",
        "-u",
        type=str,
        help="Path to file listing home-manager packages",
        default=os.environ["NIXCUSTOM_HM_PACKAGES"],
    )

    args = parser.parse_args()

    upstream = execute_message(f"Getting upstream [{args.nixpkgs}]")(
        get_upstream_full, args.nixpkgs
    )

    system = execute_message(f"Listing system environment packages [{args.env}]")(
        get_nix_store, args.env
    )
    # Additional system packages that will not be listed under in nix
    system["linux_latest"] = get_linux_drv()
    system["nvidia_x11"] = get_nvidia_drv()

    user = execute_message(f"Listing home-manager packages [{args.user}]")(
        get_nix_store, args.user
    )

    system_updates = get_discrepancies(upstream, system)
    if sum([x[1] != x[3] for x in system_updates]) == 0:
        print("System packages is up-to-date!")
    else:
        print("Updates available for system packages!")
        display_updates(system_updates)
        print("""Update with the following commands:
              cd /etc/nixos/
              nix flake update
              nixos-rebuild switch
              """)

    user_updates = get_discrepancies(upstream, user)
    if sum([x[1] != x[3] for x in user_updates]) == 0:
        print("User packages is up-to-date!")
    else:
        print("Updates available!")
        display_updates(user_updates)
        print("""Update with the following commands:
              cd ~/.config/home-manager/
              nix flake update
              home-manager switch
              """)
