#!/usr/bin/env python3
import argparse
import glob
import json
import os
import subprocess
from typing import Any, Dict, List, Tuple


def execute_message(s: str):
    """
    Decorator for long running function
    """

    def _wrap(f, *args, **kwargs):
        print(s, end="...", flush=True)
        r = f(*args, **kwargs)
        print("Done!", flush=True)
        return r

    return _wrap


def get_upstream_full(upstream_url) -> Dict[str, str]:
    nix_query = subprocess.Popen(
        ["nix", "search", "nixpkgs", "-I", upstream_url, "--json"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout, stderr = nix_query.communicate()
    return json.loads(stdout)


def drv_to_dict(drv_path: str) -> Dict[str, Any]:
    """
    Getting the DRV path using `nix derivative show`
    """
    _nix_deriv = subprocess.Popen(
        ["nix", "derivation", "show", drv_path],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout, stderr = _nix_deriv.communicate()
    return json.loads(stdout)[drv_path]


def get_nix_store(list_file: str) -> Dict[str, Any]:
    """
    Extracting the derivation information of packages listed in a plain text
    file. The plain should be a <package>-<version> line separted list,
    generated by dumping the contents of config.environment.systemPackages or
    similar.
    """
    try:
        package_list = open(list_file, "r").read().split("\n")
        drv_list = [
            path
            for pkg in package_list
            for path in glob.glob(f"/nix/store/*-{pkg}.drv")
        ]
        _nix_deriv = subprocess.Popen(
            ["nix", "derivation", "show", *drv_list],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        stdout, stderr = _nix_deriv.communicate()
        package_drv = {}
        # Additional parsing to be done
        for key, drv in json.loads(stdout).items():
            if "env" not in drv.keys():
                print(
                    f"Warning! Skipping over package [{key}] without 'env' settings",
                )
            pname = drv["name"] if "pname" not in drv["env"] else drv["env"]["pname"]
            package_drv[pname] = drv
            package_drv[pname]["drv_path"] = key
        return package_drv
    except Exception as err:
        print(f"Warning! Ran into issue processing file [f{list_file}]. Skipping...")
        print(type(err), err)
        return {}


def get_discrepancies(upstream, local) -> List[Tuple[str, str, str]]:
    updates = []
    for pname, pconfig in local.items():
        # Skipping if no-local version can be determined
        if "version" not in pconfig["env"]:
            continue
        # Getting upstream keys, ignoring if no upstream package exists
        ukeys = [
            k
            for k in [  # Allow package name varients
                f'legacyPackages.{pconfig["system"]}.{pname}',
                f'legacyPackages.{pconfig["system"]}.kdePackages.{pname}'
            ]
            if k in upstream.keys()
        ]
        if len(ukeys) == 0:
            continue

        # Getting all versions available in the upstream version
        uversions = [
            (x, upstream[x]["version"])
            for x in ukeys
            if "version" in upstream[x]
            and "git" not in upstream[x]["version"]
            and "pre" not in upstream[x]["version"]
            and "unstable" not in upstream[x]["version"]
        ]
        # Listing just the latest version for comparison
        if len(uversions) == 0:
            continue  # If there are no valid version to compare
        uversions = sorted(
            uversions,
            key=lambda x: tuple(
                int(i)
                for i in ("0" + x[1]).replace("p", ".").replace("-", ".").split(".")
                if i.isdigit()
            ),
        )
        # Adding the upstream results to the compairson table
        updates.append(
            (pname, pconfig["env"]["version"], uversions[-1][0], uversions[-1][1])
        )
    return updates


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        "nix-check-update.py", "Helper script for checking for upstream updates"
    )
    parser.add_argument(
        "--nixpkgs",
        "-n",
        type=str,
        help="URL to compare with upstream",
        default="nixpkgs=channel:nixos-unstable",
    )
    parser.add_argument(
        "--env",
        "-e",
        type=str,
        help="Path to file listing system environment packages",
        default=os.environ["NIXCUSTOM_ENV_PACKAGES"],
    )
    parser.add_argument(
        "--user",
        "-u",
        type=str,
        help="Path to file listing home-manager packages",
        default=os.environ["NIXCUSTOM_HM_PACKAGES"],
    )

    args = parser.parse_args()

    upstream = execute_message(f"Getting upstream [{args.nixpkgs}]")(
        get_upstream_full, args.nixpkgs
    )
    local = {
        **execute_message(f"Listing system environment packages [{args.env}]")(
            get_nix_store, args.env
        ),
        **execute_message(f"Listing home-manager packages [{args.user}]")(
            get_nix_store, args.user
        ),
    }
    updates = execute_message("Calculating discrepancies")(
        get_discrepancies, upstream, local
    )
    if sum([x[1] == x[2] for x in updates]) == 0:
        print("Everything is up-to-date!")
    else:
        print("Updates available!")
        for entry in updates:
            if entry[1] == entry[2]:
                print(f"{entry[0]}: {entry[1]} -> {entry[2]}")
