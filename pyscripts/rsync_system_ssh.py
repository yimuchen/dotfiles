#!/usr/bin/env python3

import fnmatch
import logging
import os
import subprocess
from dataclasses import dataclass
from typing import Dict, List, Optional, Union

import pyinotify


@dataclass
class SyncRequest(object):
    local_path: str
    remote_path: str
    include: Optional[List[str]] = None
    exclude: Optional[List[str]] = None

    def __post_init__(self):
        if not os.path.isdir(self.local_path):
            logging.getLogger().warning("Local path is not a directory!")
        if not self.remote_path.endswith("/"):
            logging.warning(
                "Remote path does not end with '/', Directory will be nested (probably not your intent)"
            )
        if self.include is None:
            self.include = []
        if self.exclude is None:
            self.exclude = []

        # Additional things to always exclude regardless of use settings.
        for default_exclude in [
            "**/.git/",  # Avoid version tracking mismatches
            "**/.git/*",
            "**/.vscode/",  # Avoid information of the editor being passed to remote machines
            "**/.vscode/*",
            "*~",  # Temporary files used by neovim editor
            "**/*~",
            "**/CMakeCache.txt",  # CMake related files
            "**/CMakeFiles/",
            "**/CMakeFiles/*",
        ]:
            if default_exclude not in self.exclude:
                self.exclude.append(default_exclude)

    @property
    def include_rsync_str(self) -> List[str]:
        # Since strings are directly passed to the command line with out shell
        # expansion, do not include the single quotes in the string.
        return [f"--include={x}" for x in self.include]

    @property
    def exclude_rsync_str(self) -> List[str]:
        return [f"--exclude={x}" for x in self.exclude]

    def should_exclude(self, path: str) -> bool:
        # !Always exlude path that is not part of the sync request
        if not path.startswith(self.local_path):
            return True
        # Exclude if matches globbing pattern
        for ex in self.exclude:
            glob_exp = os.path.join(self.local_path, ex)
            if ex.endswith("/") and fnmatch.fnmatchcase(path, glob_exp + "*"):
                logging.getLogger().debug(f"Excluding from pattern {ex}")
                return True
            if fnmatch.fnmatchcase(path, os.path.join(self.local_path, ex)):
                return True
        # Additional check for pure numeric filenames (since these are temporary files generated by the text editor)
        if os.path.basename(path).isnumeric():
            return True
        return False

    def rsync_cmd(self, host: str) -> List[str]:
        """Generating the full rsync command given a remote host"""
        return [
            "rsync",
            "-a",  # rsync in archive mode
            "-r",  # Recrusive,
            *self.include_rsync_str,  # Include/exclude strings
            *self.exclude_rsync_str,
            self.local_path,
            f"{host}:{self.remote_path}",
        ]

    def rm_file_cmd(self, host: str, filepath: str) -> List[str]:
        """
        Generating command for removing a single file. File removal is handled
        separately rather than using rsync delete options, as file may be
        dynamically generate at remote location (ex. plots) and should not be
        removed by rsync commands.
        """
        return [
            "ssh",
            host,
            "rm",
            "-f",
            filepath.replace(self.local_path, self.remote_path),
        ]


class RsyncHandler(pyinotify.ProcessEvent):
    # Main procesing flow control
    MASK = pyinotify.IN_DELETE | pyinotify.IN_CREATE | pyinotify.IN_MODIFY

    def __init__(
        self,
        config_dict: Dict[str, Union[str | Dict]],
        watch_manager: pyinotify.WatchManager,
    ):
        self.remote_host = config_dict["remote_host"]
        self.sync_list = [SyncRequest(**x) for x in config_dict["sync_list"]]
        self.watch_manager = watch_manager
        self.notifier = pyinotify.Notifier(
            self.watch_manager,
            self,
            timeout=1000,  # Check in increments of 1 seconds (avoid excessive call when editing files
        )
        for req in self.sync_list:
            logging.getLogger().debug("Added watch path", req.local_path)
            self.watch_manager.add_watch(
                req.local_path, mask=RsyncHandler.MASK, rec=True
            )
            subprocess.run(
                req.rsync_cmd(self.remote_host)
            )  # Run the rsync command one 1 start up
        self.run_list = {}

    def process_IN_CREATE(self, event: pyinotify.Event):
        logging.getLogger().debug("Creating:", event.pathname)
        self.register_rsync(event)

    def process_IN_MODIFY(self, event: pyinotify.Event):
        logging.getLogger().debug("Modifying:", event.pathname)
        self.register_rsync(event)

    def process_IN_DELETE(self, event: pyinotify.Event):
        logging.getLogger().debug("Removing:", event.pathname)
        self.register_remove(event)

    def register_rsync(self, event: pyinotify.Event):
        for sync_request in self.sync_list:
            if sync_request.should_exclude(event.pathname):
                continue
            else:
                self.run_list[  # All rsync under the same key to avoid exessively calling rsync
                    sync_request.local_path + "@@rsync"
                ] = sync_request.rsync_cmd(
                    self.remote_host
                )
                break

    def register_remove(self, event: pyinotify.Event):
        for sync_request in self.sync_list:
            if sync_request.should_exclude(event.pathname):
                continue
            else:
                self.run_list[
                    sync_request.local_path + "@@rm_" + event.pathname
                ] = sync_request.rm_file_cmd(self.remote_host, event.pathname)
                break

    def run_loop(self):
        while True:  # Mimicing loop structure in pyinotify.Notifier
            try:
                self.run_list = {}
                while (
                    self.notifier.check_events()
                ):  # loop in case more events appear while we are processing
                    self.notifier.read_events()
                    self.notifier.process_events()  # Running the various run functions
                if len(self.run_list):
                    for key, cmd in self.run_list.items():
                        logging.getLogger().info("Running command:", " ".join(cmd))
                        subprocess.run(cmd)
            except KeyboardInterrupt or InterruptedError:
                break
        self.notifier.stop()


if __name__ == "__main__":
    import argparse
    import json

    import argcomplete

    parser = argparse.ArgumentParser(
        "rsync_system_ssh", "watching file system to sync to remote system over a ssh"
    )
    parser.add_argument(
        "jsonfile",
        type=str,
        help="JSON file containing how the synchronization should be handled.",
    )

    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    configuration = json.load(open(args.jsonfile, "r"))
    rsync_handler = RsyncHandler(configuration, pyinotify.WatchManager())
    rsync_handler.run_loop()
